
void I2C_Soft_int(){
    // cap clock cho ngoai vi va I2C						// su dung kenh I2C2 cua STM32
    RCC_APB2PeriphClockCmd(RCC_AHBPeriph_GPIOA, ENABLE);
    // cau hinh chan SDA va SCL
    GPIOlib_InitStructure.GPIO_Pin = GPIO_Pin_9 | GPIO_Pin_10;						//PA9 - SCL, PA10 - SDA
    GPIOlib_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    GPIOlib_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
    GPIOlib_InitStructure.GPIO_OType = GPIO_OType_OD;
    GPIOlib_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;
    GPIO_Init(GPIOA, &GPIOlib_InitStructure);
    GPIO_WriteBit(GPIOA,SCL,1);
    GPIO_WriteBit(GPIOA,SDA,1);
}

void delay_us(long time){
    time*=SystemCoreClock/1000000;
    while(time--);
}

void generate_start(){
    GPIO_WriteBit(GPIOA,SDA,1);
    delay_us(1);
    GPIO_WriteBit(GPIOA,SCL,1);
    delay_us(1);
    GPIO_WriteBit(GPIOA,SDA,0);
    delay_us(10);
    GPIO_WriteBit(GPIOA,SCL,0);
    delay_us(10);
}

void generate_stop(){
    GPIO_WriteBit(GPIOA,SCL,0);
    delay_us(1);
    GPIO_WriteBit(GPIOA,SDA,0);
    delay_us(1);
    GPIO_WriteBit(GPIOA,SCL,1);
    delay_us(10);
    GPIO_WriteBit(GPIOA,SDA,1);
    delay_us(10);
}
uint8_t write_byte(uint8_t txByte){
    uint8_t    mask,error;
    for(mask = 0x80; mask > 0; mask >>= 1)// shift bit for masking (8 times)
    {
      if((mask & txByte) == 0) GPIO_WriteBit(GPIOA,SDA,0); // masking txByte, write bit to SDA-Line
      else                     GPIO_WriteBit(GPIOA,SDA,1);
      delay_us(1);               // data set-up time (t_SU;DAT)
      GPIO_WriteBit(GPIOA,SCL,1);                         // generate clock pulse on SCL
      delay_us(5);               // SCL high time (t_HIGH)
      GPIO_WriteBit(GPIOA,SCL,0);
      delay_us(1);               // data hold time(t_HD;DAT)
    }
    GPIO_WriteBit(GPIOA,SDA,1);                           // release SDA-line
    GPIO_WriteBit(GPIOA,SCL,1);                          // clk #9 for ack
    delay_us(1);                 // data set-up time (t_SU;DAT)
    if(GPIO_ReadInputDataBit(GPIOA,SDA)) error = 1;
    else error = 0;// check ack from i2c slave
    GPIO_WriteBit(GPIOA,SCL,0);
    delay_us(20);
    return error;
}
uint8_t read_byte(uint8_t *rxByte,uint8_t ack, long timeout)
{
  uint8_t mask,error;
  *rxByte = 0x00;
  GPIO_WriteBit(GPIOA,SDA,1);                            // release SDA-line
  for(mask = 0x80; mask > 0; mask >>= 1) // shift bit for masking (8 times)
  {
    GPIO_WriteBit(GPIOA,SCL,1);                          // start clock on SCL-line
    delay_us(1);                // clock set-up time (t_SU;CLK)
    error = I2c_Wait(timeout);// wait while clock streching
    delay_us(3);                // SCL high time (t_HIGH)
    if(GPIO_ReadInputDataBit(GPIOA,SDA)) *rxByte |= mask;        // read bit
    GPIO_WriteBit(GPIOA,SCL,0);
    delay_us(1);                // data hold time(t_HD;DAT)
  }
  if(ack) GPIO_WriteBit(GPIOA,SDA,0);   //ACK           // send acknowledge if necessary
  else           GPIO_WriteBit(GPIOA,SDA,1);  //NACK
  delay_us(1);                  // data set-up time (t_SU;DAT)
  GPIO_WriteBit(GPIOA,SCL,1);                          // clk #9 for ack
  delay_us(5);                  // SCL high time (t_HIGH)
  GPIO_WriteBit(GPIOA,SCL,0);
  GPIO_WriteBit(GPIOA,SDA,1);                           // release SDA-line
  delay_us(20);                 // wait to see byte package on scope

  return error;                          // return with no error
}
uint8_t I2c_Wait(uint8_t timeout)
{
  uint8_t error = 0;

  while(!GPIO_ReadInputDataBit(GPIOA,SCL))
  {
    if(timeout-- == 0) return 1;
    delay_us(1000);
  }

  return error;
}
uint8_t I2C_Soft_Write(uint8_t address,uint8_t* buffer,uint8_t num,uint8_t end){
    uint8_t error=0;
    generate_start();
    error=write_byte(address<<1);
    if(error) return 1;
    for(int i=0;i<num;i++){
    error=write_byte(*buffer++);
    if(error) {return 2;}
    }
    if(end) generate_stop();
    return error;
}
uint8_t I2C_Soft_Read(uint8_t address,uint8_t* buffer,uint8_t num,long timeout,uint8_t end){
    uint8_t error=0;
    generate_start();
    error=write_byte((address<<1)|1);
    if(error) return 1;

    for(int i=0;i<num;i++){
    if(i!=num-1 && i!= 0) error=read_byte(buffer++,1,0);
    else if(i==0) error=read_byte(buffer++,1,timeout);
    else error=read_byte(buffer++,0,0);

    if(error) {return 2;}
    }
    if(end) generate_stop();
    return error;
}
